#!/bin/bash

#
# dockerhub2oci - Simple shell tool to pull from DockerHub and create an OCI image.
# Copyright (C) 2018  Oliver Freyermuth
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#

function help() {
cat <<EOF
Tool to pull an image from a docker registry and extract the contents
to a folder to be used as OCI image.

Example usage:
$0 --repo gliderlabs --image alpine --tag latest
EOF
exit 1
}

# Defaults
registry="registry.hub.docker.com"
repo="gliderlabs"
image="alpine"
tag="latest"

cachedir=${TMPDIR:-/tmp}/docker2oci/

writable_dirs=false

TEMP=$(getopt -o h --long repo:,image:,tag:,cachedir:,registry:,writable-dirs,help -n $0 -- "$@")
if [ $? != 0 ] ; then printHelp; exit 1; fi
eval set -- "$TEMP"
while true ; do
	case "$1" in
		--repo)          repo=$2;            shift 2;;
		--image)         image=$2;           shift 2;;
		--tag)           tag=$2;             shift 2;;
		--cachedir)      cachedir=$2;        shift 2;;
		--registry)      registry=$2;        shift 2;;
		--writable-dirs) writable_dirs=true; shift 1;;
		-h|--help)       help;               exit 0;;
		--)              shift;              break;;
		*) echo "Internal error!";           exit 1;;
	esac
done

mkdir -p ${cachedir}

imgroot=${repo}/${image}/${tag}
rm -rf ${imgroot}
mkdir -p ${imgroot}

img_full="${repo}/${image}"

auth_uri="https://auth.docker.io/token"
auth_uri_full="${auth_uri}?service=registry.docker.io&scope=repository:${img_full}:pull"

reg_uri_manifest="https://${registry}/v2/${img_full}/manifests/${tag}"
reg_uri_blobs="https://${registry}/v2/${img_full}/blobs"

# Auth token
token=$(curl -s ${auth_uri_full} | jq -r .token)
# grep -Po '"'"token"'"\s*:\s*"\K([^"]*)')
#echo $token

# Layers
layers_raw=$(curl -s -H "Authorization: Bearer ${token}" "${reg_uri_manifest}" | jq -r .fsLayers[].blobSum)
# grep -Po '"'"blobSum"'"\s*:\s*"\K([^"]*)')
#echo "$reply"

layers=$(echo ${layers_raw} | tr ' ' '\n' | tac | uniq)
# Layers may be strangely stacked and hashes may repeat further up,
# download only fully unique layer IDs.
layers_dl=$(echo ${layers_raw} | tr ' ' '\n' | sort | uniq)

for HASHLAYER in ${layers_dl}; do
	hashtype=${HASHLAYER%:*}
	layer=${HASHLAYER#*:}
	hashtype_aria=$(echo ${hashtype} | sed 's/^\([a-z]*\)\([0-9]*\)$/\1-\2/')
	echo ${reg_uri_blobs}/${HASHLAYER}
	echo "  checksum=${hashtype_aria}=${layer}"
	echo "  out=${HASHLAYER}.tar.gz"
done | aria2c -i - -d ${cachedir} --header="Authorization: Bearer ${token}" -V

for HASHLAYER in ${layers}; do
	# Whiteout handling.
	whiteouts_unchecked=$(tar tf ${cachedir}/${HASHLAYER}.tar.gz --wildcards --wildcards-match-slash ".wh..wh..opq" "*/.wh..wh..opq" ".wh.*" "*/.wh.*" 2>/dev/null)

	# Safety: Check for filenames with newline.
	num_bad_whiteouts=$(echo -n "${whiteouts_unchecked}" | grep -v '.wh.' | wc -l)
	if [ ! ${num_bad_whiteouts} -eq 0 ]; then
		echo "There are ${num_bad_whiteouts} whiteout files with newline characters in the filename in layer ${HASHLAYER}:"
		echo "${whiteouts_unchecked}" | grep -v '.wh.'
		echo "This is likely malicious content, exiting now!"
		exit 1
	fi

	whiteouts=$(echo "${whiteouts_unchecked}" | tr '\n' '\0' | xxd -p)

	opaque_whiteouts=$(echo -n "${whiteouts}" | xxd -p -r | grep -ze '\.wh\.\.wh\.\.opq$' | xxd -p)
	explicit_whiteouts=$(echo -n "${whiteouts}" | xxd -p -r | grep -zve '\.wh\.\.wh\.\.opq$' | grep -ze '\.wh\.[^/]\+$' | xxd -p)

	if [ ! -z "${opaque_whiteouts}" ]; then
		echo "Warning: Layer ${HASHLAYER} contains opaque whiteout files:"
		while IFS= read -r -d '' whiteout_file; do
			echo "${whiteout_file}"
		done < <(echo -n "${opaque_whiteouts}" | xxd -p -r)
		echo "We do not handle these yet!"
	fi
	if [ ! -z "${explicit_whiteouts}" ]; then
		while IFS= read -r -d '' whiteout_file; do
			to_be_deleted=${imgroot}/$(echo "${whiteout_file}" | sed 's#\.wh\.\([^/]\+\)$#\1#')
			# Ensure this is below our tree
			case $(readlink -f "${to_be_deleted}") in
				$(readlink -f .)/*)
					rm -rf "${to_be_deleted}";;
				*)
					echo "ERROR!";
					echo "File ${to_be_deleted} is not below extracted tree!";
					echo "This looks malicious, exiting now!";
					exit 1;;
			esac
		done < <(echo -n "${explicit_whiteouts}" | xxd -p -r)
	fi
	tar --overwrite --exclude=dev/* --exclude=*/.wh.* -C ${imgroot} -xf ${cachedir}/${HASHLAYER}.tar.gz
	if ${writable_dirs}; then
		# make sure all directories are owner-writable
		find ${imgroot} -type d ! -perm -200 -print0|xargs -0 -r chmod u+w
	fi
done
